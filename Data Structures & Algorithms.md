
## **ğŸ“Œ A. Python Language & DS Foundations (25)**

1. Difference between list vs tuple? When to use which?
2. Time complexity of list append, insert, pop, slicing?
3. How does Python manage memory for small integers?
4. What are Python **iterators** and **iterables**?
5. What is a **generator**? How is it different from a function?
6. Explain **yield** keyword with examples.
7. What is the time complexity of `in` on lists/sets? Why?
8. Why is Pythonâ€™s list a **dynamic array** and not a linked list?
9. What is the internal implementation of **dictionary** (hash map)?
10. Explain how Python resolves hash collisions.
11. What is **hash randomization** in Python?
12. Why are Python strings **immutable**?
13. What is the difference between `deepcopy` vs `copy`?
14. How are sets implemented in Python?
15. Why is the worst-case lookup O(n) for hash tables?
16. What is monkey patching?
17. What are closures?
18. Explain decorators with real examples.
19. What is a namespace and how does Python resolve variables?
20. What is LEGB rule?
21. What is the GIL (Global Interpreter Lock)?
22. Difference between multiprocessing vs multithreading in Python?
23. What is `__slots__`?
24. What is the difference between list comprehension vs generator expression?
25. How does Python optimize list comprehensions internally?

---

## **ğŸ“Œ B. Arrays / Strings / Lists (20)**

26. Reverse a list in Python without using reverse().
27. Rotate a list by k steps.
28. Find the first non-repeating character in a string.
29. Check if two strings are anagrams using Pythonâ€™s Counter.
30. Merge two sorted lists.
31. Find the longest substring without repeating characters.
32. Count occurrences of each element using dict or Counter.
33. Move all zeros to the end.
34. Find pair with a given sum using two pointers.
35. Kadaneâ€™s Algorithm in Python.
36. Remove duplicates from a list efficiently.
37. Find the missing number from 1â€¦n.
38. Group anagrams using dictionaries.
39. Longest common prefix.
40. Trapping rain water problem.
41. Sliding window maximum using deque.
42. Reverse words in a string.
43. Implement strstr() in Python.
44. Print all permutations of a string using recursion.
45. Find the majority element using Python.

---

## **ğŸ“Œ C. Dictionaries, Sets, and Python Hashing (10)**

46. Implement LRU Cache using OrderedDict.
47. Count frequency of words in a large file.
48. Detect duplicates using set.
49. Create a set of lists (why not possible)?
50. How to make a user-defined object hashable?
51. Find top-K frequent elements using heap/dict.
52. Create a custom dictionary with limited size (eviction logic).
53. Explain how Python handles dictionary resizing.
54. Compute intersection and union of sets in O(n).
55. Explain why dict key lookup is average O(1).

---

## **ğŸ“Œ D. Linked List (15)**

56. Reverse a linked list (iterative).
57. Reverse a linked list (recursive).
58. Detect cycle using Floydâ€™s algorithm.
59. Merge two sorted linked lists in Python O(1) extra space.
60. Delete the Nth node from the end.
61. Find intersection of two linked lists.
62. Add two numbers represented by linked lists.
63. Remove duplicates from a sorted linked list.
64. Remove duplicates from an unsorted linked list using set.
65. Flatten a multi-level linked list.
66. Sort a linked list using merge sort.
67. Detect palindrome linked list.
68. Reorder a linked list (L0 â†’ Ln â†’ L1 â†’ Ln-1â€¦).
69. Rotate a linked list.
70. Clone a linked list with random pointers.

---

## **ğŸ“Œ E. Stack & Queue (10)**

71. Implement stack using list.
72. Implement queue using deque.
73. Implement min stack in Python.
74. Implement queue using two stacks.
75. Largest rectangle in histogram.
76. Next greater element.
77. Decode string: â€œ3[a2[c]]â€.
78. Evaluate postfix expression.
79. Balanced parentheses checker.
80. Sliding window using deque.

---

## **ğŸ“Œ F. Trees / BST (15)**

81. Inorder traversal (recursive & iterative).
82. Preorder traversal.
83. Postorder traversal.
84. BFS / level order traversal.
85. Check if a tree is balanced.
86. Height of a binary tree.
87. Validate BST.
88. Lowest common ancestor (BST).
89. Lowest common ancestor (binary tree).
90. Diameter of a tree.
91. Serialize and deserialize binary tree.
92. Convert sorted list to BST.
93. Kth smallest in BST (inorder).
94. Path sum problems.
95. Invert/flip a binary tree.

---

## **ğŸ“Œ G. Graphs (20)**

96. Implement BFS using queue.
97. Implement DFS using recursion.
98. Detect cycle in undirected graph.
99. Detect cycle in directed graph.
100. Number of islands.
101. Rotten oranges problem.
102. Word ladder.
103. Topological sorting (Kahnâ€™s algorithm).
104. Dijkstraâ€™s shortest path in Python using heapq.
105. Primâ€™s MST algorithm.
106. Detect bipartite graph.
107. Clone a graph.
108. Count connected components.
109. Bridges in a graph (Tarjan).
110. Articulation points.
111. Floyd-Warshall algorithm.
112. Bellman-Ford algorithm.
113. Kosarajuâ€™s SCC algorithm.
114. Cycle detection using DFS with recursion stack.
115. Backtracking: N-Queens.

---

## **ğŸ“Œ H. Searching & Sorting (10)**

116. Binary search (recursive).
117. Binary search (iterative).
118. Search in rotated sorted array.
119. Merge sort.
120. Quick sort (in-place).
121. Counting sort (Python implementation).
122. Bucket sort.
123. Radix sort.
124. Find kth largest element using heap.
125. Count inversions.

---

## **ğŸ“Œ I. Heaps / Priority Queues (10)**

126. Implement max heap using heapq (custom comparator).
127. Find k closest numbers.
128. Merge K sorted lists using heap.
129. Reorganize string so no adjacent characters are same.
130. Find median of data stream.
131. Top-K frequent words.
132. Sliding window median.
133. Connect ropes with minimum cost.
134. Kth largest element in a stream.
135. Rearrange array: positives & negatives alternate.

---

## **ğŸ“Œ J. Dynamic Programming (15)**

136. Fibonacci (top-down & bottom-up).
137. Climbing stairs.
138. House robber.
139. Coin change.
140. Longest increasing subsequence.
141. Longest common subsequence.
142. Edit distance.
143. 0/1 knapsack.
144. Partition equal subset sum.
145. Palindromic subsequence.
146. Palindromic substring.
147. Decode ways.
148. Word break.
149. Unique paths.
150. Maximum product subarray.



Tell me what you want next!
